//
//  TouchEvents.swift
//  LuciaMetricsSDK
//
//  Created by Stefan Progovac on 9/30/25.
//

import Foundation
import SwiftData
import UIKit

@available(iOS 17, *)

@Model
public final class LuciaTouchEvent: Codable, Identifiable, Equatable, @unchecked Sendable {
	public var id: UUID  // Equivalent to auto-generated primary key (use UUID for simplicity in SwiftData)

	// Custom coding keys for JSON serialization (equivalent to @SerializedName)
	enum CodingKeys: String, CodingKey {
		case id
		case sessionID
		case timestamp
		case type
		case rawX
		case rawY
		case pressure
		case size
		case velocityX
		case velocityY
		case distanceX
		case distanceY
	}

	private(set) public var sessionID: String?
	private(set) public var timestamp: Double  // TimeInterval (seconds since boot; adapt if needed)
	private(set) public var type: String
	private(set) public var rawX: Float
	private(set) public var rawY: Float
	private(set) public var pressure: Float
	private(set) public var size: Float
	private(set) public var velocityX: Float?
	private(set) public var velocityY: Float?
	private(set) public var distanceX: Float?
	private(set) public var distanceY: Float?

	// Initializer (matches the data class constructor)
	public init(
		id: UUID = UUID(),  // Auto-generated by default
		sessionID: String? = nil,
		timestamp: Double,
		type: String,
		rawX: Float,
		rawY: Float,
		pressure: Float,
		size: Float,
		velocityX: Float? = nil,
		velocityY: Float? = nil,
		distanceX: Float? = nil,
		distanceY: Float? = nil
	) {
		self.id = id
		self.sessionID = sessionID
		self.timestamp = timestamp
		self.type = type
		self.rawX = rawX
		self.rawY = rawY
		self.pressure = pressure
		self.size = size
		self.velocityX = velocityX
		self.velocityY = velocityY
		self.distanceX = distanceX
		self.distanceY = distanceY
	}

	// Custom Codable conformance if needed (for non-standard serialization)
	public init(from decoder: Decoder) throws {
		let container = try decoder.container(keyedBy: CodingKeys.self)
		self.id = try container.decode(UUID.self, forKey: .id)
		self.sessionID = try container.decodeIfPresent(String.self, forKey: .sessionID)
		self.timestamp = try container.decode(Double.self, forKey: .timestamp)
		self.type = try container.decode(String.self, forKey: .type)
		self.rawX = try container.decode(Float.self, forKey: .rawX)
		self.rawY = try container.decode(Float.self, forKey: .rawY)
		self.pressure = try container.decode(Float.self, forKey: .pressure)
		self.size = try container.decode(Float.self, forKey: .size)
		self.velocityX = try container.decodeIfPresent(Float.self, forKey: .velocityX)
		self.velocityY = try container.decodeIfPresent(Float.self, forKey: .velocityY)
		self.distanceX = try container.decodeIfPresent(Float.self, forKey: .distanceX)
		self.distanceY = try container.decodeIfPresent(Float.self, forKey: .distanceY)
	}

	public func encode(to encoder: Encoder) throws {
		var container = encoder.container(keyedBy: CodingKeys.self)
		try container.encode(id, forKey: .id)
		try container.encodeIfPresent(sessionID, forKey: .sessionID)
		try container.encode(timestamp, forKey: .timestamp)
		try container.encode(type, forKey: .type)
		try container.encode(rawX, forKey: .rawX)
		try container.encode(rawY, forKey: .rawY)
		try container.encode(pressure, forKey: .pressure)
		try container.encode(size, forKey: .size)
		try container.encodeIfPresent(velocityX, forKey: .velocityX)
		try container.encodeIfPresent(velocityY, forKey: .velocityY)
		try container.encodeIfPresent(distanceX, forKey: .distanceX)
		try container.encodeIfPresent(distanceY, forKey: .distanceY)
	}

	// Static factory methods (equivalent to companion object)
	@MainActor public static func create(touch: UITouch, in view: UIView?) -> LuciaTouchEvent {
		let location = touch.location(in: view)  // Compute raw position in view coordinates
		// TODO: pass in sessionID
		return LuciaTouchEvent(
			sessionID: "",
			timestamp: touch.timestamp,  // Seconds since boot; convert to ms since 1970 if needed: Date().timeIntervalSince1970 * 1000
			type: "touch",
			rawX: Float(location.x),
			rawY: Float(location.y),
			pressure: Float(touch.force),  // UITouch.force is CGFloat (pressure)
			size: Float(touch.majorRadius)  // Approximate size with majorRadius
		)
	}

	@MainActor public static func createFling(touch: UITouch, in view: UIView?, velocity: CGPoint?) -> LuciaTouchEvent {
		let location = touch.location(in: view)
		// TODO: pass in sessionID
		return LuciaTouchEvent(
			sessionID: "",
			timestamp: touch.timestamp,
			type: "fling",
			rawX: Float(location.x),
			rawY: Float(location.y),
			pressure: Float(touch.force),
			size: Float(touch.majorRadius),
			velocityX: velocity != nil ? Float(velocity!.x) : nil,
			velocityY: velocity != nil ? Float(velocity!.y) : nil,
			distanceX: nil,
			distanceY: nil
		)
	}

	@MainActor public static func createScroll(touch: UITouch, in view: UIView?, distance: CGPoint?) -> LuciaTouchEvent {
		let location = touch.location(in: view)
		// TODO: pass in sessionID
		return LuciaTouchEvent(
			sessionID: "",
			timestamp: touch.timestamp,
			type: "scroll/drag",
			rawX: Float(location.x),
			rawY: Float(location.y),
			pressure: Float(touch.force),
			size: Float(touch.majorRadius),
			distanceX: distance != nil ? Float(distance!.x) : nil,
			distanceY: distance != nil ? Float(distance!.y) : nil,
		)
	}
}

extension UIApplication {
	var keyWindow: UIWindow? {
		connectedScenes
			.compactMap { $0 as? UIWindowScene }
			.flatMap { $0.windows }
			.first { $0.isKeyWindow }
	}

	var firstWindow: UIWindow? {
		connectedScenes
			.compactMap { $0 as? UIWindowScene }
			.flatMap { $0.windows }
			.first
	}
}

class LuciaUITapGestureRecognizer: UITapGestureRecognizer {
	private(set) var capturedTouch: UITouch?

	override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent) {
		super.touchesBegan(touches, with: event)
		capturedTouch = touches.first
	}

	override func touchesEnded(_ touches: Set<UITouch>, with event: UIEvent) {
		super.touchesEnded(touches, with: event)
		capturedTouch = touches.first
	}

	override func reset() {
		super.reset()
		capturedTouch = nil
	}
}

class LuciaUIFlingGestureRecognizer: UIPanGestureRecognizer {
	private(set) var capturedTouches: Set<UITouch>?
	private(set) var firstTouch: UITouch?

	override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent) {
		super.touchesBegan(touches, with: event)
		capturedTouches = touches
		firstTouch = touches.first
	}

	override func touchesMoved(_ touches: Set<UITouch>, with event: UIEvent) {
		super.touchesMoved(touches, with: event)
		capturedTouches = touches
	}

	override func touchesEnded(_ touches: Set<UITouch>, with event: UIEvent) {
		super.touchesEnded(touches, with: event)
		capturedTouches = touches
	}

	override func touchesCancelled(_ touches: Set<UITouch>, with event: UIEvent) {
		super.touchesCancelled(touches, with: event)
		capturedTouches = nil
		firstTouch = nil
	}

	override func reset() {
		super.reset()
		capturedTouches = nil
		firstTouch = nil
	}
}

@available(iOS 17, *)
public extension UIApplication {

	func recordTouches() {
		addTapGestureRecognizer()
		addDragGestureRecognizer()
	}

	private func addTapGestureRecognizer() {
		guard let window = UIApplication.shared.keyWindow else { return }

		let tapGesture = LuciaUITapGestureRecognizer(target: self, action: #selector(tapAction))
		tapGesture.requiresExclusiveTouchType = false
		tapGesture.cancelsTouchesInView = false
		tapGesture.delegate = self
		window.addGestureRecognizer(tapGesture)
	}

	@objc private func tapAction(_ gesture: LuciaUITapGestureRecognizer) {
		print("[TOUCH] tap captured")

		if let touch = gesture.capturedTouch {
			let touchData = LuciaTouchEvent.create(touch: touch, in: gesture.view)
			print("[RECORD] Tap: \(touchData.id)")
			RecordTouchEvents.shared.record(touchData)
		}
	}

	private func addDragGestureRecognizer() {
		guard let window = UIApplication.shared.keyWindow else { return }

		let panGesture = LuciaUIFlingGestureRecognizer(target: self, action: #selector(dragAction(_:)))
		panGesture.cancelsTouchesInView = false
		panGesture.delegate = self
		window.addGestureRecognizer(panGesture)
	}

	@objc private func dragAction(_ gesture: LuciaUIFlingGestureRecognizer) {
		let location = gesture.location(in: gesture.view)
		let velocity = gesture.velocity(in: gesture.view)

		print("[TOUCH] drag captured")

		switch gesture.state {
		case .began:
			print("Drag started at: \(location)")
		case .changed:
			print("Dragging to: \(location)")
		case .ended:
			print("Drag ended at: \(location) with velocity: \(velocity)")
		case .cancelled, .failed:
			print("Drag cancelled")
		default:
			break
		}

		if let firstTouch = gesture.firstTouch {
			let touchData = LuciaTouchEvent.createFling(touch: firstTouch, in: gesture.view, velocity: velocity)
			print("[RECORD] Drag: \(touchData.id)")
			RecordTouchEvents.shared.record(touchData)
		}
	}

}

extension UIApplication: @retroactive UIGestureRecognizerDelegate {
	public func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer) -> Bool {
		return true // set to `false` if you don't want to detect tap during other gestures
	}
}

